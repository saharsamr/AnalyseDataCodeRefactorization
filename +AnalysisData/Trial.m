classdef Trial
    properties (Access = private)
        ID
        events
        trialNumber = []
        startTime
        endTime
        bar
        changed = []
        states
        Error
        rewardValue
        isGood2 % TODO: Ask to find a better name
        isGood1
        clueIndex = []
        changeIndex = []
        shouldKeep = []
        goodAmount = 0
        eye
        reactionTime = []
        TTW
        stateTiming
    end

    methods (Access = public)
        function extract_trial_data ( ...
                                this, ...
                                trial_index, ...
                                experiment_events, ...
                                trials_start_indices, ...
                                eye_time_samples, ...
                                data_eye, ...
                                start_time_eyelink ...
        )
            this.set_id(trial_index, trials_start_indices, experiment_events);
            this.set_trial_events( ...
                                    experiment_events, ...
                                    trial_index, ...
                                    trial_start_indices ...
            );
            this.set_trial_number();
            this.set_times();
            bar_index = this.set_bar_info(); % TODO: maybe it needs name improvment.
            changed_index = this.set_changed_flag();
            TTW_indices = this.set_TTWs();
            kept_bar_index = Utils.Util.find_all(this.events.info, 'keptBar:');
            trial_ID_index = Utils.Util.find_all(this.events.info, 'TRIALID');
            this.set_trial_states( ...
                                   bar_index, ...
                                   changed_index, ...
                                   TTW_indices, ...
                                   kept_bar_index, ...
                                   trial_ID_index ...
            );
            this.set_errors();
            this.set_reward_value();
            this.set_cue_index(trial_index);
            this.set_change_index(trial_index);
            this.set_should_keep_index(trial_index);
            this.set_good_amount();
            this.eye = AnalysisData.Eye(this, data_eye);
            this.set_is_goods(); % TODO: not a proper name at all!
            this.set_reaction_time_and_update_is_good();
            this.set_state_timings(data_eye, start_time_eyelink);
        end
    end

    methods (Access = private)
        function set_id ( ...
                          this, ...
                          trial_index, ...
                          trials_start_indices, ...
                          experiment_events ...
        )
            id_str = experiment_events.info{trials_start_indices(trial_index)};
            this.ID = Utils.Util.substr2double(id_str, ' ', 1);
        end

        function set_trial_events ( ...
                                    this, ...
                                    experiment_events, ...
                                    trial_index, ...
                                    trial_start_indices ...
        )
            start_index = trials_start_indices(trial_index);
            if trial_index ~= numel(trials_start_indices)
                end_index = trials_start_indices(trial_index+1)-1;
            else
                end_index = numel(trial_start_indices);
            end
            this.events = AnalysisData.Event( ...
                            experiment_events.info(start_index:end_index), ...
                            experiment_events.time(start_index:end_index) ...
            );
        end

        function set_trial_number (this)
            trial_num_index = Utils.Util.find_all( ...
                                                   this.events.info, ...
                                                   'trialNumber:' ...
            );
            if ~isempty(trial_num_index)
                trial_num_str = this.events.info{trial_num_index};
                this.trialNumber = Utils.Util.substr2double(trial_num_str, ' ', 1);
            end
        end

        function set_times (this)
            this.startTime = this.events.time(1);
            this.startTime = this.events.time(end);
        end

        function bar_index = set_bar_info (this)
            bar_index = Utils.Util.find_all(this.events.info, 'bar:');
            this.bar = AnalysisData.Bar( ...
                                        this.events.info(bar_index), ...
                                        this.events.time(bar_index) ...
            );
            this.bar.remakeBarSignal(this.bar, this.endTime, CONFIG.Config.BAR_SAMPLING_FREQ);
        end


        function changed_index = set_changed_flag (this)
            changed_index = Utils.Util.find_all(this.events.info, 'changed:');
            if ~isempty(changed_index)
                if ~isempty(strfind(this.events.info{changed_index(end)}, 'false'))
                    changed = 0;
                elseif ~isempty(strfind(this.events.info{changed_index(end)}, 'true'))
                    changed = 1;
                end
            end
        end

        function TTW_indices = set_TTWs (this) % TODO: no use of TTW class.
            TTW_indices   = Utils.Util.find_all(this.events.info, 'TTW:');
            for TTW_index = TTW_indices
                TTW_str = this.events.info{TTW_index};
                this.TTW.(TTW_str(1:strfind(TTW_str,':')-1)) = ...
                        Utils.Util.substr2double(TTW_str, ':', 2);
            end
        end

        function set_trial_states ( ...
                                    this, ...
                                    bar_index, ...
                                    changed_index, ...
                                    TTW_indices, ...
                                    kept_bar_index, ...
                                    trial_ID_index ...
        )
            unused_indices = Utils.Util.union_all( ...
                                                    bar_index, ...
                                                    changed_index, ...
                                                    kept_bar_index, ...
                                                    TTW_indices, ...
                                                    trial_ID_index ...
            );
            this.states = AnalysisData.Event( ...
                        this.events.info(setdiff(1:numel(this.events.info), ...
                                            unused_indices)), ...
                        this.events.time(setdiff(1:numel(this.events.info), ...
                                            unused_indices)) ...
            );
        end

        function set_errors (this)
            start_state_index = Utils.Util.find_last( ...
                                                      this.states.info, ...
                                                      'barWait=>barWait_waiter' ...
            );
            error_index = Utils.Util.find_all(this.states.info, '=>error');
            this.Error = (~isempty(error_index)) && (error_index > start_state_index);
        end

        function set_reward_value (this)
            reward_index = Utils.Util.find_all(this.states.info, 'reward:');
            if this.Error
                this.rewardValue = -1;
            elseif isempty(reward_index)
                this.rewardValue = -2;
            else
                this.rewardValue = Utils.Util.substr2double(this.states.info{reward_index}, ':', 2)/0.2;
            end
        end

        function set_cue_index (this, trial_index)
           clueIndex = Utils.Util.find_all(this.states.info, 'cueIndex:');
           if ~isempty(clueIndex)
               clueIndex = clueIndex(end);
               this.clueIndex = Utils.Util.substr2double(this.states.info{clueIndex}, ':', 2);
           else
               warning(['no cueIndex found in trial ' ...
                        num2str(trial_index) ...
                        ' events! setting it to 1!'] ...
               )
               clueIndex = 1;
               this.clueIndex = clueIndex;
           end
        end

        function set_change_index (this, trial_index)
           changeIndex = Utils.Util.find_all(this.states.info, 'changeIndex:');
            if ~isempty(changeIndex)
                changeIndex = changeIndex(end);
                this.changeIndex = Utils.Util.substr2double(this.states.info{changeIndex}, ':', 2);
            else
                warning(['no change_index found in trial ' ...
                         num2str(trial_index) ...
                         ' events! setting it to 1!'] ...
                )
                changeIndex = 1;
                this.changeIndex = changeIndex;
            end
        end

        function set_should_keep_index (this, trial_index) %TODO: functionality of this part has changed a bit. check it carefully.
            shouldKeepIndex = Utils.find_all(this.states.info, 'shouldKeep:');
            if ~isempty(shouldKeepIndex)
                if Utils.Util.do_exist(this.states.info{shouldKeepIndex(end)}, 'false')
                    this.shouldKeep = 0;
                elseif Utils.Util.do_exist(this.states.info{shouldKeepIndex(end)}, 'true')
                    this.shouldKeep = 1;
                end
            elseif Utils.Util.do_exist(this.states.info, 'stimulus_waiter=>keepWait') % TODO: does it necessary to handle this part? Do the eyelink data always have the shouldkeep data to avoid this part?
                this.shouldKeep = 1;
            elseif Utils.Util.do_exist(this.states.info, 'stimulus_waiter=>releaseWait')
                this.shouldKeep = 0;
            else
                warning(['no shouldKeepIndex found in trial ' ...
                         num2str(trial_index) ...
                         ' events! setting it to 0!'] ...
                )
                this.shouldKeep = 0;
            end
        end

        function set_good_amount (this) % TODO: functionality of this part has changed a bit. check carefully (the else case)
            if this.shouldKeep == 1
                rewardAmountIndex = Utils.Util.find_all( ...
                                                    Experiment.Properties.info, ...
                                                    'keepRewardAmount:' ...
                );
            elseif this.shouldKeep == 0
                rewardAmountIndex = Utils.Util.find_all( ...
                                                    Experiment.Properties.info, ...
                                                    'releaseRewardAmount:' ...
                );
            end
            this.goodAmount = Utils.Util.substr2double(Experiment.Properties.info{rewardAmountIndex}, ':', 2);
        end

        function set_is_goods (this) % TODO: chek functionality in the end.
            keep_trig = Utils.Util.do_exist( ...
                                             this.states.info, ...
                                             'stimulus_waiter=>keepWait' ...
            );
            release_trig = Utils.Util.do_exist( ...
                                                this.states.info, ...
                                                'stimulus_waiter=>releaseWait' ...
            );
            no_error = this.errors_occured();
            reward_state = 1.*Utils.Util.do_exist( ...
                                                   this.states.info, ...
                                                   'reward=>reward_waiter' ...
            );
            this.isGood2  = (keep_trig || release_trig) && (no_error);
            this.isGood1  = reward_state && no_error && (this.goodAmount <= this.rewardValue);
        end

        function set_reaction_time_and_update_is_good (this)
            if this.isGood1 && this.shouldKeep == 0
                temp_point_release = Utils.Util.find_all( ...
                                                          this.states.info, ...
                                                          'stimulus=>stimulus_waiter' ...
                );
                start_state_index  = Utils.Util.find_last( ...
                                                           this.states.info, ...
                                                           'barWait=>barWait_waiter' ...
                );
                if start_state_index < temp_point_release
                    try
                        release_point = find(this.bar.signal.bar( ...
                            this.bar.signal.time > this.states.time(temp_point_release) - this.startTime ...
                            )==0, 1);
                        release_point_time = this.bar.signal.time(release_point);
                        tempFromTime = Utils.Util.find_all( ...
                                                            this.states.info, ...
                                                            'releaseWait=>releaseWait_waiter' ...
                        );
                        this.reactionTime = release_point_time - (this.states.time(tempFromTime) - start_state_index);
                        this.update_is_good_respected_to_reaction_times();
                    catch
                        warning(['Bar not set to False after release in file: ' ...
                                 datestr(time_data) '!'] ...
                        )
                    end
                end
            end
        end

        function set_state_timings (this, data_eye, start_time_eyelink)
            if this.isGood2
                this.stateTiming = AnalysisData.StateTimings(this.states);
                this.eye.set_saccade_time( ...
                                           this.data_eye, ...
                                           this.state_timings, ...
                                           this.start_time_eyelink ...
                );
            end
        end

        function no_error = errors_occured (this)
            error_msg = Utils.Util.find_all(this.events.info, 'ERROR MESSAGES');
            error_msg = Utils.Util.find_all(this.events.info, 'ERROR COMMANDS');
            no_error = isempty(error_msg) && isempty(error_com);
        end

        function update_is_good_respected_to_reaction_times (this)
            if isempty(this.reactionTime)
                this.isGood1 = 0;
                warning(['Bar not set to False after release in file: ' ...
                         datestr(time_data) '!'] ...
                )
            elseif this.reactionTime < 0
                this.isGood2 = 0;
                this.isGood1 = 0;
                warning(['Bar Error Reaction time: ' ...
                         datestr(time_data) '!'] ...
                )
            end
        end
    end

end
